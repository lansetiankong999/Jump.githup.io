<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | BLOG</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">BLOG</h1><a id="logo" href="/.">BLOG</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">Oct 23, 2018</div><div class="post-content"><h2 id="Session和Cookie对像"><a href="#Session和Cookie对像" class="headerlink" title="Session和Cookie对像"></a>Session和Cookie对像</h2><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、状态管理</span><br><span class="line">2、Cookie的使用</span><br><span class="line">3、Session的使用</span><br><span class="line">4、作业</span><br></pre></td></tr></table></figure>
<h4 id="一-状态管理"><a href="#一-状态管理" class="headerlink" title="一.状态管理"></a>一.状态管理</h4><p><strong>1.状态管理原因</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议是无状态的，不能保存每次提交的信息，即当服务器返回与请求相对应的应答之后，这次事务的所有信息就丢掉了。 </span><br><span class="line">如果用户发来一个新的请求，服务器无法知道它是否与上次的请求有联系。 </span><br><span class="line">对于那些需要多次提交数据才能完成的Web操作，比如登录来说，就成问题了。</span><br></pre></td></tr></table></figure>
<p><strong>2.状态管理概念</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WEB应用中的会话（session）是指一个客户端浏览器与WEB服务器之间连续发生的一系列请求和响应过程。</span><br><span class="line">WEB应用的会话状态是指WEB服务器与浏览器在会话过程中产生的状态信息，借助会话状态，WEB服务器能够把属于同一会话中的一系列的请求和响应过程关联起来。</span><br></pre></td></tr></table></figure>
<p><strong>3.状态管理的两种常见模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器状态管理技术：</span><br><span class="line">将状态保存在服务器端。代表性的是session技术（服务器传递sessionID时需要使用Cookie的方式）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端状态管理技术：将状态保存在客户端。代表性的是Cookie技术。</span><br></pre></td></tr></table></figure>
<h4 id="二-Cookie对像"><a href="#二-Cookie对像" class="headerlink" title="二.Cookie对像"></a>二.Cookie对像</h4><p><strong>1.概念</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie是在浏览器访问WEB服务器的某个资源时，由WEB服务器在HTTP响应消息头中附带传送给浏览器的一片数据，WEB服务器传送给各个客户端浏览器的数据是可以各不相同的。</span><br><span class="line">一旦WEB浏览器保存了某个Cookie，那么它在以后每次访问该WEB服务器时，都应在HTTP请求头中将这个Cookie回传给WEB服务器。</span><br><span class="line">WEB服务器通过在HTTP响应消息中增加Set-Cookie响应头字段将Cookie信息发送给浏览器，浏览器则通过在HTTP请求消息中增加Cookie请求头字段将Cookie回传给WEB服务器。</span><br><span class="line">一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。</span><br><span class="line">一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。</span><br><span class="line">浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB</span><br><span class="line">Cookie不支持存放中文字符信息</span><br></pre></td></tr></table></figure>
<p><strong>2.服务端创建Cookie的方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie=new Cookie(&quot;key&quot;, value);</span><br><span class="line"></span><br><span class="line">//设置Cookie的路径</span><br><span class="line">cookie.setPath(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">//内存存储，取值有三种,单位为秒</span><br><span class="line">//大于0表示cookie生效时间，等于0表示失效，小于0表示内存存储，不写入浏览器</span><br><span class="line">cookie.setMaxAge(-1);</span><br><span class="line"></span><br><span class="line">//把cookie写入客户端浏览器</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p><strong>3.服务器查询客户端Cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//获取所有的Cookie</span><br><span class="line">Cookie[] cks=request.getCookies();</span><br><span class="line">//遍历Cookie</span><br><span class="line">for(Cookie ck:cks)&#123;</span><br><span class="line">     //通过key值，检索出自己的Cookie</span><br><span class="line">	if(ck.getName().equals(&quot;key&quot;))&#123;</span><br><span class="line">       	//记录Cookie的值</span><br><span class="line">		code=ck.getValue();</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.修改Cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只需要保证Cookie的key 及 路径一致即可修改</span><br><span class="line"></span><br><span class="line">//重新写入value2值</span><br><span class="line">Cookie cookie=new Cookie(&quot;key&quot;, value2);</span><br><span class="line">cookie.setPath(&quot;/&quot;);</span><br><span class="line">cookie.setMaxAge(-1);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p><strong>5.Cookie的编码与解码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中文和英文字符不同，中文属于Unicode字符，在内存中占用4个字节，而英文属于ASCII字符，内存中只占2个字节。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会出现乱码。</span><br><span class="line">编码可以使用java.net.URLEncoder类的encode(String str,String encoding)方法，</span><br><span class="line">解码使用java.net.URLDecoder类的decode(String str,String encoding)方法</span><br></pre></td></tr></table></figure>
<p><strong>6.代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用中文的 Cookie. </span><br><span class="line">//其中 name 与 value 都使用 UTF-8 编码. </span><br><span class="line">String key = URLEncoder.encode(&quot;姓名&quot;, &quot;UTF-8&quot;);</span><br><span class="line">String value= URLEncoder.encode(&quot;张三&quot;, &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">Cookie cookie = new Cookie(key,value）;</span><br><span class="line">// 发送到客户端   </span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p><strong>7.Cookie的路径问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie一般都是由于用户访问页面而被创建的，可是并不是只有在创建cookie的页面才可以访问这个cookie。</span><br><span class="line">在默认情况下，出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置</span><br></pre></td></tr></table></figure>
<p><strong>8.浏览器发送Cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先域名匹配，再路径匹配：</span><br><span class="line">浏览器在发送请求之前，首先会根据请求url中的域名在cookie列表中找所有与当前域名一样的cookie，然后再根据指定的路径进行匹配.</span><br><span class="line">如果两者都匹配成功，那么就会将所有匹配的cookie发送给服务器。</span><br><span class="line">这里要注意的是最大匹配和最小匹配问题，有些cookie服务器在发送之前会有意扩大当前页面cookie的匹配范围，此时这些被扩大范围的cookie也会一起发送给服务器</span><br></pre></td></tr></table></figure>
<p><strong>9.设置Cookie的路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setPath(&quot;&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>10.Cookie的特点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">可配置到期规则 Cookie 可以在浏览器会话结束时到期，或者可以在客户端计算机上无限期存在，这取决于客户端的到期规则。</span><br><span class="line">不需要任何服务器资源 Cookie 存储在客户端并在发送后由服务器读取。</span><br><span class="line">简单性 Cookie 是一种基于文本的轻量结构，包含简单的键值对。</span><br><span class="line">数据持久性，虽然客户端计算机上 Cookie 的持续时间取决于客户端上的 Cookie 过期处理和用户干预，Cookie 通常是客户端上持续时间最长的数据保留形式</span><br><span class="line"></span><br><span class="line">缺点： </span><br><span class="line">1.大小受到限制</span><br><span class="line">	大多数浏览器对 Cookie 的大小有 4096 字节的限制，尽管在当今新的浏览器和客户端设备版本中，支持 8192字节的Cookie大小已愈发常见。</span><br><span class="line">2.用户配置为禁用</span><br><span class="line">	有些用户禁用了浏览器或客户端设备接收 Cookie 的能力，因此限制了这一功能。</span><br><span class="line">3.潜在的安全风险</span><br><span class="line">	Cookie 可能会被篡改。用户可能会操纵其计算机上的 Cookie，这意味着会对安全性造成潜在风险或者导致依赖于 Cookie 的应用程序失败。</span><br><span class="line">	另外，虽然 Cookie 只能被将它们发送到客户端的域访问，历史上黑客已经发现从用户计算机上的其他域访问 Cookie 的方法。您可以手动加密和解密 Cookie，但这需要额外的编码，并且因为加密和解密需要耗费一定的时间而影响应用程序的性能。</span><br></pre></td></tr></table></figure>
<h4 id="三-Session对像"><a href="#三-Session对像" class="headerlink" title="三.Session对像"></a>三.Session对像</h4><p><strong>1.概念</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session用于跟踪客户的状态。</span><br><span class="line">Session指的是在一段时间内，单个客户与Web服务器的一连串相关的交互过程。</span><br><span class="line">在一个Session中，客户可能会多次请求访问同一个网页，也有可能请求访问各种不同的服务器资源。</span><br></pre></td></tr></table></figure>
<p><strong>2.原理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session被用于表示一个持续的连接状态，在网站访问中一般指代客户端浏览器的进程从开启到结束的过程。</span><br><span class="line">session其实就是网站分析的访问（visits）度量，表示一个访问的过程。</span><br><span class="line">session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid时，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的 session。</span><br><span class="line">这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。　</span><br><span class="line">但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现</span><br></pre></td></tr></table></figure>
<p><strong>3.获取Session</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session=request.getSession();</span><br></pre></td></tr></table></figure>
<p><strong>4.Session常用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">唯一标记：</span><br><span class="line">session.getId());</span><br><span class="line">最后一次访问时间，毫秒	:</span><br><span class="line">session.getLastAccessedTime();</span><br><span class="line">获取最大的空闲时间，单位秒:</span><br><span class="line">session.getMaxInactiveInterval();</span><br><span class="line">获取Session的创建，单位毫秒:		</span><br><span class="line">session.getCreationTime();</span><br></pre></td></tr></table></figure>
<p><strong>5.使用Session绑定对像</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpSession.setAttribute(属性名,Object);</span><br><span class="line"></span><br><span class="line">//删除session中绑定的对像</span><br><span class="line">HttpSession.removeAttribute(属性名);</span><br></pre></td></tr></table></figure>
<p><strong>6.删除Session</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession.invalidate();</span><br></pre></td></tr></table></figure>
<p><strong>7.Session超时</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession的最后一程访问时间和当前时间的差距大于了指定的最大空闲时间，这时服务器就会销毁Session对象。默认的空闲时间为30分钟。</span><br></pre></td></tr></table></figure>
<p><strong>8.修改Session的缺省时间限制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession.setMaxInactiveInterval(10)，单位秒</span><br></pre></td></tr></table></figure>
<p><strong>9.Session失效几中机制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、超过了设置的超时时间</span><br><span class="line">2、主动调用了invalidate方法</span><br><span class="line">3、服务器主动或异常关闭</span><br><span class="line">注意：浏览器关闭并不会让Session失效</span><br></pre></td></tr></table></figure>
<p><strong>10.浏览器禁用Cookie,导致Session不可用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果浏览器禁用Cookie，session将不可用。</span><br><span class="line">原因是：服务器要读取客户端Cookie的值，来确定此次连接和之前连接是否是同一会话Session，判断标准是读取Cookie中存放的SessionID值。</span><br><span class="line">如果浏览器禁用，则服务器不能把SessionID写入客户端浏览器，则Session的判断标准将失去作用。</span><br><span class="line"></span><br><span class="line">解决方式：</span><br><span class="line">服务器可以使用如URL重写这样的方式来发送jsessionID.</span><br><span class="line">sessionId不能写入cookie，只能通过查询字符串的方式拼接在URL后面，响应给客户端</span><br></pre></td></tr></table></figure>
<p><strong>11.URL重写</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浏览器在访问服务器上的某个地址时，不再使用原来的那个地址，而是使用经过改写的地址</span><br><span class="line">（即，在原来的地址后面加上了sessionID）</span><br></pre></td></tr></table></figure>
<p><strong>12.URL重写的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生成重写后的URL：</span><br><span class="line">1、response.encodeURL(String url）</span><br><span class="line">2、response.encodeRedirectURL(String url)</span><br><span class="line">该方法的实现机制为： </span><br><span class="line">● 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。 </span><br><span class="line">● 再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。</span><br></pre></td></tr></table></figure>
<p><strong>13.两种重写方法异同</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line">都对url附加上jsessionid参数进行了处理，如果需要.则在url的path后面附加上;jsessionid=xxx；如果不需要则直接返回传入的url。</span><br><span class="line">不同点：</span><br><span class="line">encodeURL()是本应用级别的，encodeRedirectURL()是跨应用的。</span><br></pre></td></tr></table></figure>
<p><strong>14.代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package encodeURL;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * URL重写，解决Cookie被禁用</span><br><span class="line"> * @author kevin</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/encode.do&quot;)</span><br><span class="line">public class EncodeURLServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		</span><br><span class="line">		HttpSession session = request.getSession();</span><br><span class="line">		response.getWriter().println(&quot;encodeURL&quot;);</span><br><span class="line">		String url = &quot;login.html&quot;;</span><br><span class="line">		/*</span><br><span class="line">		1.先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。 </span><br><span class="line">		2.再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；</span><br><span class="line">		3.如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。 </span><br><span class="line">		 */</span><br><span class="line">		String newUrl = response.encodeURL(url);</span><br><span class="line">		System.out.println(newUrl);</span><br><span class="line">		response.sendRedirect(newUrl);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四-作业"><a href="#四-作业" class="headerlink" title="四.作业"></a>四.作业</h4></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/10/23/Servlet的Request和Response对像/"></a><a class="next" href="/2018/10/23/Filter和Listener/"></a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://kongxianghe.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/spring boot 与spring cloud/">spring boot 与spring cloud</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/maven将外部jar添加到本地仓库/">maven将外部jar添加到本地仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/docker的安装/">docker的安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/centos7安装mysql5.6教程/">centos7安装mysql5.6教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/数据库存入移动端表情出错/">数据库存入移动端表情出错</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/Java内存模型（JMM）/">Java内存模型（JMM）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/进程，端口，服务/">进程，端口，服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/javascript前端脚本技术/">javascript前端脚本技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/CSS样式表/">CSS样式表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/javaScript前端脚本技术二/">javaScript前端脚本技术二</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">BLOG.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>